import { useState, useEffect, useCallback } from "react";
import { supabase } from "@/integrations/supabase/client";
import { Game, DatabaseGame, DatabaseRound } from "@/types/game";

export const useGames = (showDeleted: boolean = false) => {
  const [games, setGames] = useState<Game[]>([]);
  const [loading, setLoading] = useState(true);

  const convertDatabaseGameToGame = (
    dbGame: DatabaseGame,
    rounds: DatabaseRound[] = []
  ): Game => {
    const gameRounds = rounds.map((round) => ({
      round: round.round_number,
      teamA: {
        bid: round.team_a_bid,
        won: round.team_a_won,
        bags: round.team_a_bags,
        score: round.team_a_score,
      },
      teamB: {
        bid: round.team_b_bid,
        won: round.team_b_won,
        bags: round.team_b_bags,
        score: round.team_b_score,
      },
    }));

    return {
      id: dbGame.id,
      teamA: {
        name: dbGame.team_a_name,
        players: dbGame.team_a_players || [],
      },
      teamB: {
        name: dbGame.team_b_name,
        players: dbGame.team_b_players || [],
      },
      rounds: gameRounds,
      status: dbGame.status as "active" | "completed",
      winner: dbGame.winner,
      finalScores:
        dbGame.final_score_team_a !== null && dbGame.final_score_team_b !== null
          ? {
              teamA: dbGame.final_score_team_a,
              teamB: dbGame.final_score_team_b,
            }
          : undefined,
      createdAt: new Date(dbGame.created_at),
      finishedAt: dbGame.finished_at ? new Date(dbGame.finished_at) : undefined,
      maxRounds: dbGame.max_rounds,
      deleted: dbGame.deleted,
      deletedAt: dbGame.deleted_at ? new Date(dbGame.deleted_at) : undefined,
    };
  };

  const fetchGames = useCallback(async () => {
    try {
      setLoading(true);
      let query = supabase
        .from("games")
        .select("*");
      
      if (!showDeleted) {
        query = query.eq("deleted", false);
      }

      const { data: gamesData, error: gamesError } = await query
        .order("created_at", { ascending: false });

      if (gamesError) throw gamesError;

      const gamesWithoutRounds = gamesData.map((game) =>
        convertDatabaseGameToGame(game as DatabaseGame)
      );
      setGames(gamesWithoutRounds);
    } catch (error) {
      console.error("Error fetching games:", error);
    } finally {
      setLoading(false);
    }
  }, [showDeleted]);

  const fetchGameDetails = async (gameId: string) => {
    try {
      // First, fetch the game data to ensure we have the latest game information
      const { data: gameData, error: gameError } = await supabase
        .from("games")
        .select("*")
        .eq("id", gameId)
        .single();

      if (gameError) throw gameError;

      // Then fetch the rounds data
      const { data: roundsData, error: roundsError } = await supabase
        .from("rounds")
        .select("*")
        .eq("game_id", gameId)
        .order("round_number");

      if (roundsError) throw roundsError;

      // Convert the game data including the rounds
      const updatedGame = convertDatabaseGameToGame(
        gameData as DatabaseGame,
        roundsData
      );

      // Update the games state with the new data
      setGames((prev) =>
        prev.map((game) => (game.id === gameId ? updatedGame : game))
      );

      return updatedGame;
    } catch (error) {
      console.error("Error fetching game details:", error);
      throw error;
    }
  };
  useEffect(() => {
    fetchGames();
  }, [fetchGames]);

  const createGame = async (
    teamAName: string,
    teamBName: string,
    teamAPlayers: string[],
    teamBPlayers: string[],
    maxRounds: number
  ) => {
    try {
      const {
        data: { user },
      } = await supabase.auth.getUser();
      if (!user) throw new Error("User not authenticated");

      const { data: gameData, error: gameError } = await supabase
        .from("games")
        .insert({
          user_id: user.id,
          team_a_name: teamAName,
          team_b_name: teamBName,
          team_a_players: teamAPlayers,
          team_b_players: teamBPlayers,
          status: "active",
          max_rounds: maxRounds,
        })
        .select()
        .single();

      if (gameError) throw gameError;

      // Create first round with zero values
      const { error: roundError } = await supabase.from("rounds").insert({
        game_id: gameData.id,
        round_number: 1,
        team_a_bid: 0,
        team_a_won: 0,
        team_a_bags: 0,
        team_a_score: 0,
        team_b_bid: 0,
        team_b_won: 0,
        team_b_bags: 0,
        team_b_score: 0,
      });

      if (roundError) throw roundError;

      const firstRound: DatabaseRound = {
        id: "", // This will be generated by the database
        game_id: gameData.id,
        round_number: 1,
        team_a_bid: 0,
        team_a_won: 0,
        team_a_bags: 0,
        team_a_score: 0,
        team_b_bid: 0,
        team_b_won: 0,
        team_b_bags: 0,
        team_b_score: 0,
      };

      const newGame = convertDatabaseGameToGame(gameData as DatabaseGame, [
        firstRound,
      ]);
      setGames((prev) => [newGame, ...prev]);
      return newGame;
    } catch (error) {
      console.error("Error creating game:", error);
      throw error;
    }
  };

  const updateRound = async (
    gameId: string,
    roundNumber: number,
    teamAData: { bid: number; won: number; bags: number; score: number },
    teamBData: { bid: number; won: number; bags: number; score: number }
  ) => {
    try {
      const { error } = await supabase.from("rounds").upsert(
        {
          game_id: gameId,
          round_number: roundNumber,
          team_a_bid: teamAData.bid,
          team_a_won: teamAData.won,
          team_a_bags: teamAData.bags,
          team_a_score: teamAData.score,
          team_b_bid: teamBData.bid,
          team_b_won: teamBData.won,
          team_b_bags: teamBData.bags,
          team_b_score: teamBData.score,
        },
        { onConflict: "game_id, round_number" }
      );

      if (error) throw error;

      setGames((prev) =>
        prev.map((game) => {
          if (game.id === gameId) {
            return {
              ...game,
              rounds: game.rounds.map((round) => {
                if (round.round === roundNumber) {
                  return {
                    ...round,
                    teamA: { ...teamAData },
                    teamB: { ...teamBData },
                  };
                }
                return round;
              }),
            };
          }
          return game;
        })
      );
    } catch (error) {
      console.error("Error updating round:", error);
      throw error;
    }
  };

  const completeGame = async (
    gameId: string,
    winner: string,
    finalScores: { teamA: number; teamB: number }
  ) => {
    try {
      const { error } = await supabase
        .from("games")
        .update({
          status: "completed",
          winner,
          final_score_team_a: finalScores.teamA,
          final_score_team_b: finalScores.teamB,
          finished_at: new Date().toISOString(),
        })
        .eq("id", gameId);

      if (error) throw error;

      setGames((prev) =>
        prev.map((game) => {
          if (game.id === gameId) {
            return {
              ...game,
              status: "completed" as const,
              winner,
              finalScores,
              finishedAt: new Date(),
            };
          }
          return game;
        })
      );
    } catch (error) {
      console.error("Error completing game:", error);
      throw error;
    }
  };

  const deleteGame = async (gameId: string) => {
    try {
      const { error } = await supabase
        .from("games")
        .update({ deleted: true, deleted_at: new Date().toISOString() })
        .eq("id", gameId);

      if (error) throw error;

      setGames((prev) => prev.filter((game) => game.id !== gameId));
    } catch (error) {
      console.error("Error deleting game:", error);
      throw error;
    }
  };

  return {
    games,
    loading,
    createGame,
    updateRound,
    completeGame,
    deleteGame,
    refetchGames: fetchGames,
    fetchGameDetails,
  };
};
